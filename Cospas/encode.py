# -*- coding: utf-8 -*-
"""Encode.ipynb

Automatically generated by Colaboratory.


"""

import matplotlib.pyplot as plt
import numpy as np
import hashlib
import hmac
import os
import time
import binascii
import wave
import array

def  hexconv(msg):
    # Convert binary list to a string
    binary_string = ''.join(str(bit) for bit in msg)
    # Convert binary string to hexadecimal string
    hex_string = hex(int(binary_string, 2))
    return hex_string


def file_dump(name,msg):
  temp_array = bytearray(0)
  temp_array.extend(msg)
  fx = open(name, "wb")
  fx.write(temp_array)
  return None

def bch_cal(message,polynomy,n):
  i = 1
  start_position = message.find('1')
  end_position = start_position + len(polynomy)
  digest = message[start_position:end_position]

  while i < len(message):
    xor_output = int(digest,2) ^ int(polynomy,2)
    xor_output_binary = ('{0:b}'.format(xor_output))
    if len(xor_output_binary) < len(polynomy):
      required_bit = len(polynomy) - len(xor_output_binary)
      digest= xor_output_binary+ message[end_position:end_position+required_bit]
      end_position = end_position + required_bit
    else:
      return digest.zfill(n)
      break

def str2list(string):
    list1 = []
    list1[:0] = string
    return list(map(int, list1))

class EPIRB:
    def __init__(self,format_flag, protocol_flag,country_code,protocol_type,MMSI,specific_beacon,latitude_sign,latitude_degree,latitude_minute,
                 longitude_sign,longitude_degree,longitude_minute,fixed_bits,position_data_source,aux_device,latitiude_offset_sign,
                 latitiude_offset_minute,latitiude_offset_second,longitude_offset_sign,longitude_offset_minute,longitude_offset_second):
        self.format_flag = format_flag
        self.protocol_flag = protocol_flag
        self.country_code=country_code
        self.protocol_type=protocol_type
        self.MMSI=MMSI
        self.specific_beacon=specific_beacon
        self.latitude_sign= latitude_sign
        self.latitude_degree=latitude_degree
        self.latitude_minute=latitude_minute
        self.longitude_sign=longitude_sign
        self.longitude_degree=longitude_degree
        self.longitude_minute=longitude_minute
        self.fixed_bits=fixed_bits
        self.position_data_source=position_data_source
        self.aux_device=aux_device
        self.latitiude_offset_sign = latitiude_offset_sign
        self.latitiude_offset_minute= latitiude_offset_minute
        self.latitiude_offset_second=latitiude_offset_second
        self.longitude_offset_sign=longitude_offset_sign
        self.longitude_offset_minute=longitude_offset_minute
        self.longitude_offset_second=longitude_offset_second


    def BCH_1(self):
      n =21 # for the first BCH
      polynomy = str(1001101101100111100011)
      temp_message = (self.format_flag+self.protocol_flag+self.country_code+self.protocol_type+self.MMSI+self.specific_beacon+
            self.latitude_sign+self.latitude_degree+self.latitude_minute+self.longitude_sign+
            self.longitude_degree+self.longitude_minute)
      message= temp_message.ljust(n + len(temp_message), '0') ## 21 bit BCH first initize with 0s
      return bch_cal(message,polynomy,n)

    def BCH_2(self):
      n =12 # for the 2nd BCH
      polynomy = str(1010100111001)
      temp_message = (self.fixed_bits+self.position_data_source+aux_device+self.latitiude_offset_sign
                 +self.latitiude_offset_minute+self.latitiude_offset_second+self.longitude_offset_sign
                 +self.longitude_offset_minute+self.longitude_offset_second)
      message= temp_message.ljust(n + len(temp_message), '0') ## 12 bit BCH first initize with 0s
      return bch_cal(message,polynomy,n)

    def long_message(self):
      long_msg = (self.format_flag+self.protocol_flag+self.country_code+self.protocol_type+self.MMSI+self.specific_beacon+
            self.latitude_sign+self.latitude_degree+self.latitude_minute+self.longitude_sign+
            self.longitude_degree+self.longitude_minute)+ self.BCH_1()+ (self.fixed_bits+self.position_data_source+aux_device+self.latitiude_offset_sign
                 +self.latitiude_offset_minute+self.latitiude_offset_second+self.longitude_offset_sign
                 +self.longitude_offset_minute+self.longitude_offset_second) + self.BCH_2()
      if len(long_msg)!=120:
        print("There are some error!")
      else:
          return long_msg

shared_key = b'\r\xa1\x14&\x1d>\xbaIw\x82\x94\x11\xaa\x1a\xa5\x88\xa7\xef\xaf\x1ab\x17\xd6\xbbm\xc6KZ/\xe7vh'

# Here is the example of a EPIRB long message. 24 bits RF prerequisite + 120 bit payload = 144bit message.
hexdata = "90127B92922BC02B4968F58450220B"
scale = 16 ## equals to hexadecimal
num_of_bits = len(hexdata)*4
binary_data = bin(int(hexdata, scale))[2:].zfill(num_of_bits)

# We can initialize the data fileds according to this example but later manipulate them as we wish.
format_flag = binary_data [0]                      # 25th bit
protocol_flag = binary_data [1]                    # 26th bit
country_code = binary_data [2:12]                  # 27-36 bit
protocol_type = binary_data[12:16]                 # 37-40 bit
MMSI = binary_data [16:36]                         # 41-60 bit
specific_beacon = binary_data [36:40]              # 61-64 bit
latitude_sign = binary_data [40]                   # 65th bit
latitude_degree = binary_data [41:48]              # 66-72 bit
latitude_minute = binary_data [48:50]              # 73-74 bit
longitude_sign = binary_data [50]                  # 75th bit
longitude_degree = binary_data [51:59]             # 76-83 bit
longitude_minute = binary_data [59:61]             # 84-85 bit
#BCH1_encoded = binary_data[61:82]                 # 86-106 bit
fixed_bits = binary_data[82:86]                    # 107-110 bit
position_data_source = binary_data [86]            # 111th bit
aux_device = binary_data [87]                      # 112th bit
latitiude_offset_sign = binary_data[88]            # 113 bit
latitiude_offset_minute = binary_data[89:94]       # 114-118 bit
latitiude_offset_second = binary_data[94:98]       # 119-122 bit
longitude_offset_sign = binary_data[98]            # 123 bit
longitude_offset_minute = binary_data[99:104]      # 124-128 bit
longitude_offset_second = binary_data[104:108]     # 129-132 bit
#BCH2_encoded = binary_data[108:120]               # 133-144

"""
## IMPORTANT NOTE ##

When any data field is manipulated, the binary length needs to be the same as defined in the protocol by adding zeros (0)
at the left-hand side. For example, the length of the country_code field is 10 bits. The country code of Finland in integer is 230,
while converting that 230 into binary, it is 11100110, which is not 10 bit in length. We need to add two zeros to maintain the same length.
So the country code of Finland would be 0011100110. And the same rule applies to all the data fields.
"""

country_code = "0100000101"

protocol_type="0111"
# protocol_type 0010 = EPIRB, 0011 = ELT, 0111 = PLB

################## Start of RF stuffs ########################
bits_per_second = 400
gap = [3]*int(10)
unmodulated_carrier = [2]*int(bits_per_second*0.160)
bit_syn = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
frame_syn_test = [0,1,1,0,1,0,0,0,0]
################## END of RF stuffs ########################

# how many messages needed? we are generating 10 messages, aiming DoS attack
N = 1
N_payload_final = bytearray(0)

for i in range(N):

  r = ('{0:b}'.format(i))

  MMSI = r.zfill(20)

  obj = EPIRB(format_flag, protocol_flag,country_code,protocol_type,MMSI,specific_beacon,latitude_sign,latitude_degree,latitude_minute,
                  longitude_sign,longitude_degree,longitude_minute,fixed_bits,position_data_source,aux_device,latitiude_offset_sign,
                  latitiude_offset_minute,latitiude_offset_second,longitude_offset_sign,longitude_offset_minute,longitude_offset_second)

  preamble_string = ''.join(str(bit) for bit in bit_syn)
  frame_string = ''.join(str(bit) for bit in frame_syn_test)
  tem= obj.long_message()
  timestamp = (bin(int(time.time()))[2:])
  message_without_timestamp_str   = preamble_string + frame_string + tem
  message_including_timestamp_str = preamble_string + frame_string + tem + timestamp


  message_including_timestamp_byte = bytes([int(message_including_timestamp_str[i:i+8], 2) for i in range(0, len(message_including_timestamp_str), 8)]) # in byte format

  mac = hmac.new(shared_key, message_including_timestamp_byte, hashlib.sha256).digest()
  mac_binary_string = ''.join(format(byte, '08b') for byte in mac)
  send_mac=str2list(mac_binary_string)

  full_msg = gap + unmodulated_carrier + str2list(message_including_timestamp_str) + send_mac
  full_msg_without_radio_stuff = str2list(message_including_timestamp_str) + send_mac

  print(len(full_msg_without_radio_stuff))
  #print('full transmission =', hexconv(str2list(full_msg_without_radio_stuff)))
  print('Message_and_time  =' ,hexconv(str2list(message_including_timestamp_str)))
  print('MAC               =', hexconv(send_mac))
  print('Timestamp         =', hexconv((str2list(timestamp))))
  N_payload_final.extend(full_msg)

# wiritng the file
file_dump("PLB.iq8s",N_payload_final)  ## for HackRF in BPSK format ##

arr =[]
load = full_msg_without_radio_stuff
high = [127]*60
low =  [-128]*60
x = binary_string = ''.join(str(bit) for bit in load)
for i in range(len(x)):
  if int(x[i])==1:
    arr= arr+high+low
  elif int(x[i])==0:
    arr= arr+low+high
  else:
    print('error')

noise =  [0]*60*250

arr = noise + arr + noise

# Convert signed 8-bit data to unsigned 8-bit data
unsigned_arr = array.array('B', [sample + 128 for sample in arr])

with wave.open("PLB.wav", "wb") as wav_file:
    wav_file.setnchannels(1)  # Mono audio
    wav_file.setsampwidth(1)  # Sample width in bytes
    wav_file.setframerate(48000)  # Sample rate in Hz
    waveform = array.array('B', unsigned_arr) # h, b: Represents a signed char, typically 1 byte in size. # B: Represents an unsigned char, typically 1 byte in size.
    wav_file.writeframes(waveform.tobytes())  ## for HackRF in .wav format ##
